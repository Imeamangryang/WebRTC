/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var common;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@websr/websr/dist/websr.js":
/*!*************************************************!*\
  !*** ./node_modules/@websr/websr/dist/websr.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/context.ts\":\n/*!************************!*\\\n  !*** ./src/context.ts ***!\n  \\************************/\n/***/ (function(__unused_webpack_module, exports) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nclass WebGPUContext {\\n    constructor(device, resolution, canvas, debug) {\\n        this.device = device;\\n        this.canvas = canvas;\\n        this.resolution = resolution;\\n        this.textures = {};\\n        this.buffers = {};\\n        this.destroyed = false;\\n        this.debug = debug;\\n        let context = this.canvas.getContext('webgpu');\\n        if (context instanceof GPUCanvasContext) {\\n            this.context = context;\\n        }\\n        else {\\n            throw new Error(\\\"Unable to load WebGPU context\\\");\\n        }\\n        this.context.configure({\\n            device: this.device,\\n            format: navigator.gpu.getPreferredCanvasFormat()\\n        });\\n        this.textureUsage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;\\n        this.bufferUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\\n        if (this.debug) {\\n            // Read output pixel value\\n            this.textureUsage = this.textureUsage | GPUTextureUsage.COPY_SRC;\\n            this.bufferUsage = this.bufferUsage | GPUBufferUsage.COPY_SRC;\\n        }\\n        this.textures['output'] = this.context.getCurrentTexture();\\n    }\\n    readBuffer(bufferName) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (!this.buffers[bufferName])\\n                throw new Error(`No buffer with name ${bufferName}`);\\n            const readEncoder = this.device.createCommandEncoder({\\n                label: `Read ${bufferName} buffer encoder`,\\n            });\\n            const buffer = this.buffers[bufferName];\\n            const resultBuffer = this.device.createBuffer({\\n                label: 'result buffer',\\n                size: buffer.size,\\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\\n            });\\n            readEncoder.copyBufferToBuffer(buffer, 0, resultBuffer, 0, resultBuffer.size);\\n            this.device.queue.submit([readEncoder.finish()]);\\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\\n            let range = resultBuffer.getMappedRange();\\n            return new Float32Array(range);\\n        });\\n    }\\n    readTexture(textureName) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (!this.textures[textureName])\\n                throw new Error(`No texture with name ${textureName}`);\\n            const readEncoder = this.device.createCommandEncoder({\\n                label: `Read ${textureName} texture encoder`,\\n            });\\n            const texture = this.textures[textureName];\\n            let bitsPerPixel = 16;\\n            if (texture.format === 'rgba8unorm')\\n                bitsPerPixel = 4;\\n            if (texture.format === 'r32float')\\n                bitsPerPixel = 4;\\n            const resultBuffer = this.device.createBuffer({\\n                label: 'result buffer',\\n                size: texture.width * texture.height * bitsPerPixel,\\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\\n            });\\n            readEncoder.copyTextureToBuffer({\\n                texture: this.textures[textureName],\\n            }, {\\n                buffer: resultBuffer,\\n                bytesPerRow: texture.width * bitsPerPixel\\n            }, {\\n                width: texture.width,\\n                height: texture.height,\\n                depthOrArrayLayers: 1,\\n            });\\n            this.device.queue.submit([readEncoder.finish()]);\\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\\n            if (texture.format === 'r32float')\\n                return new Float32Array(resultBuffer.getMappedRange());\\n            else if (texture.format === 'rgba32float')\\n                return new Float32Array(resultBuffer.getMappedRange());\\n            else if (texture.format === 'rgba8unorm')\\n                return new Uint8ClampedArray(resultBuffer.getMappedRange());\\n            return new Float32Array(0);\\n        });\\n    }\\n    destroy() {\\n        this.device.destroy();\\n        this.destroyed = true;\\n    }\\n    buffer(key, options) {\\n        if (!this.buffers[key]) {\\n            options = options || {};\\n            const width = options.width || this.resolution.width;\\n            const height = options.height || this.resolution.height;\\n            const channels = options.channels || 4;\\n            const bitdepth = options.bitdepth || 4;\\n            this.buffers[key] = this.device.createBuffer({\\n                label: key,\\n                size: width * height * channels * bitdepth,\\n                usage: this.bufferUsage\\n            });\\n        }\\n        return this.buffers[key];\\n    }\\n    texture(key, options) {\\n        if (!this.textures[key]) {\\n            options = options || {};\\n            this.textures[key] = this.device.createTexture({\\n                label: key,\\n                size: [options.width || this.resolution.width, options.height || this.resolution.height],\\n                format: options.format || 'rgba32float',\\n                usage: this.textureUsage\\n            });\\n        }\\n        return this.textures[key];\\n    }\\n}\\nexports[\\\"default\\\"] = WebGPUContext;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/context.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-112x4.ts\":\n/*!********************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-112x4.ts ***!\n  \\********************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv112x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights, first) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv112x4\\\";\\n        const kernels = weights.weights;\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 28>\\\");\\n        let read_buffers = '';\\n        for (let i = 0; i < 7; i++) {\\n            if (first) {\\n                read_buffers += `\\n                let pixel_val${i} = inputBuffer${i}[buff_ind];\\n                result += kernels[${4 * i}]*max(pixel_val${i}, vec4f(0.0));\\n                result += kernels[${4 * i + 2}]*max(-1.0*pixel_val${i}, vec4f(0.0));\\n            `;\\n            }\\n            else {\\n                read_buffers += `\\n                let pixel_val${i} = inputBuffer${i}[buff_ind];\\n                result += kernels[${4 * i + 1}]*max(pixel_val${i}, vec4f(0.0));\\n                result += kernels[${4 * i + 3}]*max(-1.0*pixel_val${i}, vec4f(0.0));`;\\n            }\\n        }\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n               \\n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\\n                ${read_buffers}\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.defaultSetup();\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            compute: {\\n                module: this.shader,\\n                entryPoint: 'main',\\n            },\\n        };\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        this.uniforms.forEach((uniform, i) => {\\n            entries.push({\\n                binding: i + this.inputs.length,\\n                resource: {\\n                    buffer: this.buffers[uniform.name]\\n                }\\n            });\\n        });\\n        if (this.output instanceof GPUBuffer) {\\n            entries.push({\\n                binding: this.inputs.length + this.uniforms.length,\\n                resource: {\\n                    buffer: this.output\\n                }\\n            });\\n        }\\n        if (entries.length === 0)\\n            return null;\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv112x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-112x4.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-16x4.ts\":\n/*!*******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-16x4.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv16x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv16x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 36>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n                      \\n                 for(var i = 0u; i < 9; i++){\\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\\n                   \\n                   let pix_val0 = inputBuffer0[buff_ind];\\n                   let pix_val1 = inputBuffer1[buff_ind];\\n                  \\n                   result += kernels[i]*max(pix_val0, vec4f(0.0));\\n                   result += kernels[i+9]*max(pix_val1, vec4f(0.0));\\n                   result += kernels[i+18]*max(-1.0*pix_val0, vec4f(0.0));\\n                   result += kernels[i+27]*max(-1.0*pix_val1, vec4f(0.0));\\n                 } \\n                 \\n\\n                    \\n                result += bias;\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, -1, 0, 0,\\n            0, 0, 0, 0,\\n            0, 1, 0, 0,\\n            1, -1, 0, 0,\\n            1, 0, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv16x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-16x4.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-3x4.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-3x4.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv3x4 extends base_compute_layer_1.default {\\n    constructor(inputTextures, outputBuffer, weights) {\\n        super(inputTextures, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv3x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 9>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        // Set up pipeline in Lazy Load\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, -1, 0, 0,\\n            0, 0, 0, 0,\\n            0, 1, 0, 0,\\n            1, -1, 0, 0,\\n            1, 0, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[0] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureLoad(inputTexture0, coord + offset)' :\\n            'textureLoad(inputTexture0, coord + offset, 0)';\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n                      \\n                 for(var i = 0u; i < 9; i++){\\n                   let offset = vec2<i32>(kernel_offsets[i].xy);\\n                   result += kernels[i]*${textureLoad};\\n                 } \\n                    \\n                result += bias;\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.pipeline = this.device.createComputePipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv3x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-3x4.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-56x4.ts\":\n/*!*******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-56x4.ts ***!\n  \\*******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv56x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv56x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 14>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        let read_buffers = '';\\n        for (let i = 0; i < 7; i++) {\\n            read_buffers += `\\n            let pixel_val${i} = inputBuffer${i}[buff_ind];\\n            result += kernels[${2 * i}]*max(pixel_val${i}, vec4f(0.0));\\n            result += kernels[${2 * i + 1}]*max(-1.0*pixel_val${i}, vec4f(0.0));\\n            `;\\n        }\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n               \\n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\\n                ${read_buffers}\\n                      \\n                result += bias;\\n                \\n                outputBuffer[buff_ind] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            compute: {\\n                module: this.shader,\\n                entryPoint: 'main',\\n            },\\n        };\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        this.uniforms.forEach((uniform, i) => {\\n            entries.push({\\n                binding: i + this.inputs.length,\\n                resource: {\\n                    buffer: this.buffers[uniform.name]\\n                }\\n            });\\n        });\\n        if (this.output instanceof GPUBuffer) {\\n            entries.push({\\n                binding: this.inputs.length + this.uniforms.length,\\n                resource: {\\n                    buffer: this.output\\n                }\\n            });\\n        }\\n        if (entries.length === 0)\\n            return null;\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv56x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-56x4.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-8x4.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-8x4.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConv8x4 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConv8x4\\\";\\n        const kernels = weights.weights;\\n        const bias = weights.bias;\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.createUniform(\\\"kernels\\\", \\\"array<mat4x4f, 18>\\\");\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n                      \\n                 for(var i = 0u; i < 9; i++){\\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\\n                   \\n                   let pix_val = inputBuffer0[buff_ind];\\n                  \\n                   result += kernels[i]*max(pix_val, vec4f(0.0));\\n                   result += kernels[i+9]*max(-1.0*pix_val, vec4f(0.0));\\n                 } \\n                    \\n                result += bias;\\n                \\n                outputBuffer[i] = result;\\n          }\\n        `);\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, -1, 0, 0,\\n            0, 0, 0, 0,\\n            0, 1, 0, 0,\\n            1, -1, 0, 0,\\n            1, 0, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.setUniform(\\\"kernels\\\", new Float32Array(kernels));\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConv8x4;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-8x4.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/conv2d-concat2.ts\":\n/*!**********************************************!*\\\n  !*** ./src/layers/anime4k/conv2d-concat2.ts ***!\n  \\**********************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \\\"./src/layers/base_compute_layer.ts\\\");\\nclass Anime4KConcat2 extends base_compute_layer_1.default {\\n    constructor(inputs, outputBuffer, weights) {\\n        super(inputs, outputBuffer, weights);\\n        this.label = \\\"Anime4KConcat2\\\";\\n        this.createUniform(\\\"bias\\\", \\\"vec4f\\\");\\n        const bias = weights.bias;\\n        this.shader = this.createStandardShader(`\\n        \\n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\\n          \\n                let x = id.x;\\n                let y = id.y;\\n                \\n                let i = id.y*${this.resolution.width} + x;\\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\\n                \\n                let coord = vec2<i32>( i32(x), i32(y));\\n               \\n                let buff_ind = coord.y*${this.resolution.width} + coord.x;\\n               \\n                outputBuffer[buff_ind] = inputBuffer0[buff_ind] + inputBuffer1[buff_ind] + bias;\\n          }\\n        `);\\n        this.setUniform(\\\"bias\\\", new Float32Array(bias));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KConcat2;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-concat2.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/display.ts\":\n/*!***************************************!*\\\n  !*** ./src/layers/anime4k/display.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass DisplayLayer extends base_render_layer_1.default {\\n    constructor(inputs, output) {\\n        super(inputs, output);\\n        this.label = \\\"DisplayLayer\\\";\\n        this.vertexScale = {\\n            width: 1,\\n            height: 1\\n        };\\n        this.sampler = this.device.createSampler({\\n            addressModeU: \\\"repeat\\\",\\n            addressModeV: \\\"repeat\\\",\\n            magFilter: \\\"linear\\\",\\n            minFilter: \\\"linear\\\",\\n            mipmapFilter: \\\"linear\\\",\\n        });\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[1] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)' :\\n            'textureSample(inputTexture, ourSampler, input.tex_coord)';\\n        this.shader = this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n                \\n                   ${this.defaultVertexShader()}\\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\\n                   @group(0) @binding(1) var inputTexture: ${externalTexture ? 'texture_external' : 'texture_2d<f32>'};\\n                   @group(0) @binding(2) var ourSampler: sampler;\\n                  \\n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                      \\n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\\n                        \\n                        let y2 = u32(floor(y));\\n                        let x2 = u32(floor(x));\\n                        \\n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\\n                       \\n                        let x_floor  = u32(fract(x)*2.0);\\n                        let y_floor  = u32(fract(y)*2.0);\\n                        \\n                        //I don t know, I think this is right? I found this by trial and error\\n                        let c_index: u32 = x_floor + y_floor*2;  \\n        \\n                        let value = inputBuffer0[i][c_index];\\n                        \\n                        let bicubic = ${textureLoad};\\n                        \\n                        return bicubic + vec4f(value);\\n                    \\n                      }            \\n            `\\n        });\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        entries.push({ binding: this.inputs.length, resource: this.sampler });\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = DisplayLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/anime4k/display_3c.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/anime4k/display_3c.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass DisplayLayer3C extends base_render_layer_1.default {\\n    constructor(inputs, output) {\\n        super(inputs, output);\\n        this.label = \\\"DisplayLayer3C\\\";\\n        this.vertexScale = {\\n            width: 1,\\n            height: 1\\n        };\\n        this.sampler = this.device.createSampler({\\n            addressModeU: \\\"repeat\\\",\\n            addressModeV: \\\"repeat\\\",\\n            magFilter: \\\"linear\\\",\\n            minFilter: \\\"linear\\\",\\n            mipmapFilter: \\\"linear\\\",\\n        });\\n    }\\n    lazyLoadSetup() {\\n        const externalTexture = this.inputs[3] instanceof GPUExternalTexture;\\n        const textureLoad = externalTexture ? 'textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)' :\\n            'textureSample(inputTexture, ourSampler, input.tex_coord)';\\n        this.shader = this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n                \\n                   ${this.defaultVertexShader()}\\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\\n                   @group(0) @binding(1) var<storage, read_write> inputBuffer1: array<vec4f>;\\n                   @group(0) @binding(2) var<storage, read_write> inputBuffer2: array<vec4f>;\\n                   @group(0) @binding(3) var inputTexture: ${externalTexture ? 'texture_external' : 'texture_2d<f32>'};\\n                   @group(0) @binding(4) var ourSampler: sampler;\\n                  \\n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                      \\n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\\n                        \\n                        let y2 = u32(floor(y));\\n                        let x2 = u32(floor(x));\\n                        \\n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\\n                       \\n                        let x_floor  = u32(fract(x)*2.0);\\n                        let y_floor  = u32(fract(y)*2.0);\\n                        \\n                        //I don t know, I think this is right? I found this by trial and error\\n                        let c_index: u32 = x_floor + y_floor*2;  \\n        \\n                        let value = inputBuffer0[i][c_index];\\n                        let value1 = inputBuffer1[i][c_index];\\n                        let value2 = inputBuffer2[i][c_index];\\n                        \\n                        let bicubic = ${textureLoad};\\n                        \\n                        return bicubic + vec4f(value, value1, value2, value2);\\n                    \\n                      }            \\n            `\\n        });\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            vertex: {\\n                module: this.shader,\\n                entryPoint: 'vertexMain',\\n            },\\n            fragment: {\\n                module: this.shader,\\n                entryPoint: 'fragmentMain',\\n                targets: [{ format: this.output.format }],\\n            },\\n        };\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        entries.push({ binding: this.inputs.length, resource: this.sampler });\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = DisplayLayer3C;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display_3c.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/base_compute_layer.ts\":\n/*!******************************************!*\\\n  !*** ./src/layers/base_compute_layer.ts ***!\n  \\******************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_layer_1 = __webpack_require__(/*! ./base_layer */ \\\"./src/layers/base_layer.ts\\\");\\nclass ComputeLayer extends base_layer_1.default {\\n    constructor(inputTextures, outputBuffer, weights) {\\n        super(inputTextures, outputBuffer, weights);\\n        this.num_work_groups = 8;\\n    }\\n    createStandardShader(computeShader) {\\n        return this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n              \\n              ${this.computeShaderInputs()}\\n              \\n              ${computeShader}\\n        `\\n        });\\n    }\\n    computeShaderInputs() {\\n        const inputs = [];\\n        for (let i = 0; i < this.inputs.length; i++) {\\n            if (this.inputs[i] instanceof GPUTexture) {\\n                inputs.push(`@group(0) @binding(${i}) var inputTexture${i}: texture_2d<f32>;`);\\n            }\\n            else if (this.inputs[i] instanceof GPUExternalTexture) {\\n                inputs.push(`@group(0) @binding(${i}) var inputTexture${i}: texture_external;`);\\n            }\\n            else if (this.inputs[i] instanceof GPUBuffer) {\\n                inputs.push(`@group(0) @binding(${i}) var<storage, read_write> inputBuffer${i}: array<vec4f>;`);\\n            }\\n            else {\\n                console.log(this.inputs[i]);\\n                throw new Error(\\\"Input is undefined or non of the correct input type\\\");\\n            }\\n        }\\n        //  console.log(\\\"This layer\\\", this.label);\\n        // console.log(this.inputs.length);\\n        this.uniforms.forEach((uniform, i) => {\\n            inputs.push(`@group(0) @binding(${i + this.inputs.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\\n        });\\n        inputs.push(`@group(0) @binding(${this.inputs.length + this.uniforms.length}) var <storage, read_write> outputBuffer: array<vec4f>;`);\\n        return inputs.join('\\\\n');\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            compute: {\\n                module: this.shader,\\n                entryPoint: 'main',\\n            },\\n        };\\n    }\\n    defaultSetup() {\\n        this.pipeline = this.device.createComputePipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n    }\\n    lazyLoadSetup() {\\n    }\\n    run() {\\n        const encoder = this.device.createCommandEncoder({ label: this.label });\\n        if (!this.pipeline)\\n            this.lazyLoadSetup();\\n        const pass = encoder.beginComputePass({ label: this.label });\\n        pass.setPipeline(this.pipeline);\\n        if (this.hasExternalTexture()) {\\n            this.bindGroup = this.defaultBindGroup();\\n        }\\n        if (this.bindGroup) {\\n            pass.setBindGroup(0, this.bindGroup);\\n        }\\n        // Dividing into work groups speeds up inference. If width or height aren't cleandly divided by work groups, we round to the nearest multiple of work-groups\\n        // Physically, this means shaving a few pixels (up to num_work_groups-1) off the bottom and right edges of the canvas but users shouldn't notice?\\n        pass.dispatchWorkgroups(Math.floor(this.resolution.width / this.num_work_groups), Math.floor(this.resolution.height / this.num_work_groups));\\n        pass.end();\\n        this.device.queue.submit([encoder.finish()]);\\n    }\\n}\\nexports[\\\"default\\\"] = ComputeLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/base_compute_layer.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/base_layer.ts\":\n/*!**********************************!*\\\n  !*** ./src/layers/base_layer.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, exports) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nclass Layer {\\n    constructor(inputs, output, weights) {\\n        this.context = globalThis.context;\\n        this.device = this.context.device;\\n        this.resolution = this.context.resolution;\\n        this.inputs = inputs;\\n        this.output = output;\\n        this.uniforms = [];\\n        this.buffers = {};\\n        this.weights = weights;\\n    }\\n    createUniform(name, type) {\\n        this.uniforms.push({ name, type });\\n    }\\n    setUniform(name, value) {\\n        const buffer = this.device.createBuffer({\\n            label: `layer-${this.label}-buffer-${name}`,\\n            size: value.byteLength,\\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\\n        });\\n        this.device.queue.writeBuffer(buffer, /*bufferOffset=*/ 0, value);\\n        this.buffers[name] = buffer;\\n    }\\n    defaultBindGroup() {\\n        const entries = [];\\n        this.inputs.forEach(function (input, i) {\\n            if (input instanceof GPUExternalTexture) {\\n                entries.push({ binding: i, resource: input });\\n            }\\n            else if (input instanceof GPUTexture) {\\n                entries.push({ binding: i, resource: input.createView() });\\n            }\\n            else if (input instanceof GPUBuffer) {\\n                entries.push({ binding: i, resource: { buffer: input } });\\n            }\\n        });\\n        this.uniforms.forEach((uniform, i) => {\\n            entries.push({\\n                binding: i + this.inputs.length,\\n                resource: {\\n                    buffer: this.buffers[uniform.name]\\n                }\\n            });\\n        });\\n        if (this.output instanceof GPUBuffer) {\\n            entries.push({\\n                binding: this.inputs.length + this.uniforms.length,\\n                resource: {\\n                    buffer: this.output\\n                }\\n            });\\n        }\\n        if (entries.length === 0)\\n            return null;\\n        return this.device.createBindGroup({\\n            layout: this.pipeline.getBindGroupLayout(0),\\n            entries\\n        });\\n    }\\n    hasExternalTexture() {\\n        for (const input of this.inputs) {\\n            if (input instanceof GPUExternalTexture)\\n                return true;\\n        }\\n        return false;\\n    }\\n    lazyLoadSetup() { }\\n    run() { }\\n}\\nexports[\\\"default\\\"] = Layer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/base_layer.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/base_render_layer.ts\":\n/*!*****************************************!*\\\n  !*** ./src/layers/base_render_layer.ts ***!\n  \\*****************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_layer_1 = __webpack_require__(/*! ./base_layer */ \\\"./src/layers/base_layer.ts\\\");\\nclass RenderLayer extends base_layer_1.default {\\n    constructor(inputs, output, weights) {\\n        super(inputs, output, weights);\\n        this.vertexScale = this.context.resolution;\\n    }\\n    defaultVertexShader() {\\n        return `\\n        \\n             struct VertexShaderOutput {\\n                @builtin(position) position: vec4f,\\n                @location(0) tex_coord: vec2f,\\n              };\\n\\n            @vertex\\n            fn vertexMain( @builtin(vertex_index) vertexIndex : u32) ->  VertexShaderOutput{\\n                let pos = array(\\n                // 1st triangle\\n                vec2f( -1.0,  -1.0),  // center\\n                vec2f( 1.0,  -1.0),  // right, center\\n                vec2f( -1.0,  1.0),  // center, top\\n             \\n                // 2st triangle\\n                vec2f( -1.0,  1.0),  // center, top\\n                vec2f( 1.0,  -1.0),  // right, center\\n                vec2f( 1.0,  1.0),  // right, top\\n              );\\n             \\n              var vsOutput: VertexShaderOutput;\\n              let xy = pos[vertexIndex];\\n              vsOutput.position = vec4f(xy, 0.0, 1.0);\\n              vsOutput.tex_coord = xy*0.5 + 0.5;\\n              vsOutput.tex_coord.y = - 1.0* vsOutput.tex_coord.y  + 1.0;\\n               vsOutput.tex_coord.x =  vsOutput.tex_coord.x*${this.vertexScale.width};\\n               vsOutput.tex_coord.y =  vsOutput.tex_coord.y*${this.vertexScale.height};\\n              return vsOutput;\\n            }\\n        `;\\n    }\\n    defaultPipelineConfig() {\\n        return {\\n            label: `${this.label}-pipeline`,\\n            layout: 'auto',\\n            vertex: {\\n                module: this.shader,\\n                entryPoint: 'vertexMain',\\n            },\\n            fragment: {\\n                module: this.shader,\\n                entryPoint: 'fragmentMain',\\n                targets: [{ format: this.output.format }],\\n            },\\n        };\\n    }\\n    defaultSetup() {\\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\\n        this.bindGroup = this.defaultBindGroup();\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n    defaultRenderPassDescriptor() {\\n        return {\\n            label: `${this.label}-render-pass`,\\n            colorAttachments: [\\n                {\\n                    view: this.output.createView(),\\n                    clearValue: [0, 0, 0, 1],\\n                    loadOp: 'clear',\\n                    storeOp: 'store',\\n                },\\n            ],\\n        };\\n    }\\n    createStandardShader(fragmentShader) {\\n        return this.device.createShaderModule({\\n            label: `${this.label}-shader`,\\n            code: `\\n          \\n              ${this.defaultVertexShader()}\\n              \\n              ${this.fragmentShaderInputs()}\\n              \\n              ${fragmentShader}\\n        `\\n        });\\n    }\\n    fragmentShaderInputs() {\\n        const inputs = [];\\n        for (let i = 0; i < this.inputs.length; i++) {\\n            let type = (this.inputs[i] instanceof GPUTexture) ? 'texture_2d<f32>' : 'texture_external';\\n            inputs.push(`@group(0) @binding(0) var inputTexture${i}: ${type};`);\\n        }\\n        this.uniforms.forEach((uniform, i) => {\\n            inputs.push(`@group(0) @binding(${i + this.inputs.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\\n        });\\n        return inputs.join('\\\\n');\\n    }\\n    run() {\\n        const encoder = this.device.createCommandEncoder({ label: this.label });\\n        if (!this.pipeline)\\n            this.lazyLoadSetup();\\n        const pass = encoder.beginRenderPass(this.renderPassDescriptor);\\n        pass.setPipeline(this.pipeline);\\n        if (this.hasExternalTexture()) {\\n            this.bindGroup = this.defaultBindGroup();\\n        }\\n        if (this.bindGroup) {\\n            pass.setBindGroup(0, this.bindGroup);\\n        }\\n        pass.draw(6); // call our vertex shader 6 times\\n        pass.end();\\n        this.device.queue.submit([encoder.finish()]);\\n    }\\n    setOutput(outputTexture) {\\n        this.output = outputTexture;\\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\\n    }\\n}\\nexports[\\\"default\\\"] = RenderLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/base_render_layer.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/utils/gaussian.ts\":\n/*!**************************************!*\\\n  !*** ./src/layers/utils/gaussian.ts ***!\n  \\**************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass GuassianLayer extends base_render_layer_1.default {\\n    constructor(inputTextures, outputTexture) {\\n        super(inputTextures, outputTexture);\\n        this.label = \\\"Gaussian\\\";\\n        this.createUniform(\\\"gaussian\\\", \\\"array<vec3f, 3>\\\");\\n        this.createUniform(\\\"kernel_offsets\\\", \\\"array<vec4f, 9>\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n                  \\n                     var val  = 0.0;\\n                      \\n                     for(var i = 0u; i < 3; i++){\\n                     \\n                        let a = vec3f(\\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x\\n                        );\\n                        \\n                        val += dot(a, gaussian[i]);\\n                      \\n                    } \\n                  \\n                    \\n                    return vec4f(val, val, val, 1.0);\\n                  }                 \\n        `);\\n        this.setUniform(\\\"gaussian\\\", new Float32Array([\\n            0.0675, 0.125, 0.0675, 0.0,\\n            0.125, 0.250, 0.1250, 0.0,\\n            0.0675, 0.125, 0.0675, 0.0\\n        ]));\\n        this.setUniform(\\\"kernel_offsets\\\", new Float32Array([\\n            -1, -1, 0, 0,\\n            0, -1, 0, 0,\\n            1, -1, 0, 0,\\n            -1, 0, 0, 0,\\n            0, 0, 0, 0,\\n            1, 0, 0, 0,\\n            -1, 1, 0, 0,\\n            0, 1, 0, 0,\\n            1, 1, 0, 0,\\n        ]));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = GuassianLayer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/utils/gaussian.ts?\");\n\n/***/ }),\n\n/***/ \"./src/layers/utils/rgb_2_yuv.ts\":\n/*!***************************************!*\\\n  !*** ./src/layers/utils/rgb_2_yuv.ts ***!\n  \\***************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass RGB2YUV extends base_render_layer_1.default {\\n    constructor(inputTextures, outputTexture) {\\n        super(inputTextures, outputTexture);\\n        this.createUniform(\\\"rgb2yuv\\\", \\\"mat3x3f\\\");\\n        this.shader = this.createStandardShader(`\\n        \\n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\\n              \\n                    let color = textureLoad(inputTexture0, vec2<i32>(input.tex_coord), 0);       \\n                    let yuv = rgb2yuv*color.xyz;\\n          \\n                return vec4f(yuv, 1.0);\\n              }     \\n        `);\\n        this.setUniform(\\\"rgb2yuv\\\", new Float32Array([\\n            0.299, -0.1473, 0.615, 1.0,\\n            0.587, -.2886, -.51499, 1.0,\\n            0.114, 0.436, -.1001, 1.0\\n        ]));\\n        this.defaultSetup();\\n    }\\n}\\nexports[\\\"default\\\"] = RGB2YUV;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/layers/utils/rgb_2_yuv.ts?\");\n\n/***/ }),\n\n/***/ \"./src/main.ts\":\n/*!*********************!*\\\n  !*** ./src/main.ts ***!\n  \\*********************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst context_1 = __webpack_require__(/*! ./context */ \\\"./src/context.ts\\\");\\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \\\"./src/renderer.ts\\\");\\nconst network_list_1 = __webpack_require__(/*! ./networks/network_list */ \\\"./src/networks/network_list.ts\\\");\\nclass WebSR {\\n    constructor(params) {\\n        this.source = params.source;\\n        const source = this.source;\\n        this.resolution = params.resolution ? params.resolution : {\\n            width: (source instanceof HTMLVideoElement) ? source.videoWidth : (source instanceof HTMLImageElement) ? source.naturalWidth : source.width,\\n            height: (source instanceof HTMLVideoElement) ? source.videoHeight : (source instanceof HTMLImageElement) ? source.naturalHeight : source.height\\n        };\\n        if (params.canvas)\\n            this.canvas = params.canvas;\\n        else {\\n            this.canvas = new HTMLCanvasElement();\\n            this.canvas.width = this.resolution.width * 2;\\n            this.canvas.height = this.resolution.height * 2;\\n        }\\n        this.context = new context_1.default(params.gpu, this.resolution, this.canvas, this.debug);\\n        globalThis.context = this.context;\\n        if (!network_list_1.NetworkList[params.network_name])\\n            throw Error(`Network ${params.network_name} is not defined or implemented`);\\n        this.network = new network_list_1.NetworkList[params.network_name](params.weights);\\n        this.renderer = new renderer_1.default(this.network, this.source);\\n    }\\n    switchNetwork(network, weights) {\\n        if (!network_list_1.NetworkList[network])\\n            throw Error(`Network ${network} is not defined or implemented`);\\n        this.network = new network_list_1.NetworkList[network](weights);\\n        this.renderer.switchNetwork(this.network);\\n    }\\n    static initWebGPU() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (!navigator.gpu)\\n                return false;\\n            const adapter = yield navigator.gpu.requestAdapter();\\n            if (!adapter)\\n                return false;\\n            const device = yield adapter.requestDevice();\\n            if (!device)\\n                return false;\\n            return device;\\n        });\\n    }\\n    start() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.start();\\n        });\\n    }\\n    stop() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.stop();\\n        });\\n    }\\n    render(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.render(source);\\n        });\\n    }\\n    destroy() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            yield this.renderer.stop();\\n            this.context.destroy();\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = WebSR;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/main.ts?\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-2x-l.ts\":\n/*!******************************************!*\\\n  !*** ./src/networks/anime4k/cnn-2x-l.ts ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst display_3c_1 = __webpack_require__(/*! ../../layers/anime4k/display_3c */ \\\"./src/layers/anime4k/display_3c.ts\\\");\\nconst conv2d_16x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-16x4 */ \\\"./src/layers/anime4k/conv2d-16x4.ts\\\");\\nconst conv2d_112x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-112x4 */ \\\"./src/layers/anime4k/conv2d-112x4.ts\\\");\\nconst conv2d_concat2_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-concat2 */ \\\"./src/layers/anime4k/conv2d-concat2.ts\\\");\\nclass Anime4KCNN2XL extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        layers.push(new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']));\\n        layers.push(new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf1'), weights['conv2d_tf1']));\\n        for (let i = 1; i < 7; i++) {\\n            let source = (i == 1) ? `conv2d_tf` : `conv2d_${i - 1}_tf`;\\n            layers.push(new conv2d_16x4_1.default([context.buffer(source), context.buffer(source + \\\"1\\\")], context.buffer(`conv2d_${i}_tf`), weights[`conv2d_${i}_tf`]));\\n            layers.push(new conv2d_16x4_1.default([context.buffer(source), context.buffer(source + \\\"1\\\")], context.buffer(`conv2d_${i}_tf1`), weights[`conv2d_${i}_tf1`]));\\n        }\\n        for (let c = 0; c < 3; c++) {\\n            const sources_0 = [];\\n            const sources_1 = [];\\n            for (let i = 0; i < 7; i++) {\\n                let source = (i == 0) ? `conv2d_tf` : `conv2d_${i}_tf`;\\n                sources_0.push(context.buffer(source));\\n                sources_1.push(context.buffer(source + \\\"1\\\"));\\n            }\\n            const dest = (c == 0) ? `conv2d_last_tf` : `conv2d_last_tf${c}`;\\n            layers.push(new conv2d_112x4_1.default(sources_0, context.buffer(`conv2d_last_${c}_pt1`), weights[dest], true));\\n            layers.push(new conv2d_112x4_1.default(sources_1, context.buffer(`conv2d_last_${c}_pt2`), weights[dest], false));\\n            layers.push(new conv2d_concat2_1.default([context.buffer(`conv2d_last_${c}_pt1`), context.buffer(`conv2d_last_${c}_pt2`)], context.buffer(dest), weights[dest]));\\n        }\\n        const paint = new display_3c_1.default([context.buffer('conv2d_last_tf'), context.buffer('conv2d_last_tf1'), context.buffer('conv2d_last_tf2'), context.input], context.texture('output'));\\n        layers.push(paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (source instanceof HTMLVideoElement) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = source instanceof ImageBitmap ? source : yield createImageBitmap(source);\\n                const width = source instanceof HTMLImageElement ? source.naturalWidth : source.width;\\n                const height = source instanceof HTMLImageElement ? source.naturalHeight : source.height;\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[1].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[3] = this.context.input;\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNN2XL;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-l.ts?\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-2x-m.ts\":\n/*!******************************************!*\\\n  !*** ./src/networks/anime4k/cnn-2x-m.ts ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \\\"./src/layers/anime4k/conv2d-8x4.ts\\\");\\nconst conv2d_56x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-56x4 */ \\\"./src/layers/anime4k/conv2d-56x4.ts\\\");\\nconst display_3c_1 = __webpack_require__(/*! ../../layers/anime4k/display_3c */ \\\"./src/layers/anime4k/display_3c.ts\\\");\\nclass Anime4KCNN2XM extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\\n        const conv2d_3_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_3_tf'), weights['conv2d_3_tf']);\\n        const conv2d_4_tf = new conv2d_8x4_1.default([context.buffer('conv2d_3_tf')], context.buffer('conv2d_4_tf'), weights['conv2d_4_tf']);\\n        const conv2d_5_tf = new conv2d_8x4_1.default([context.buffer('conv2d_4_tf')], context.buffer('conv2d_5_tf'), weights['conv2d_5_tf']);\\n        const conv2d_6_tf = new conv2d_8x4_1.default([context.buffer('conv2d_5_tf')], context.buffer('conv2d_6_tf'), weights['conv2d_6_tf']);\\n        const conv2d_7_tf = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_7_tf'), weights['conv2d_7_tf']);\\n        const conv2d_7_tf1 = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_7_tf1'), weights['conv2d_7_tf1']);\\n        const conv2d_7_tf2 = new conv2d_56x4_1.default([context.buffer('conv2d_tf'), context.buffer('conv2d_1_tf'), context.buffer('conv2d_2_tf'), context.buffer('conv2d_3_tf'), context.buffer('conv2d_4_tf'), context.buffer('conv2d_5_tf'), context.buffer('conv2d_6_tf')], context.buffer('conv2d_7_tf2'), weights['conv2d_7_tf2']);\\n        const paint = new display_3c_1.default([context.buffer('conv2d_7_tf'), context.buffer('conv2d_7_tf1'), context.buffer('conv2d_7_tf2'), context.input], context.texture('output'));\\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_3_tf, conv2d_4_tf, conv2d_5_tf, conv2d_6_tf, conv2d_7_tf, conv2d_7_tf1, conv2d_7_tf2, paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (source instanceof HTMLVideoElement) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = source instanceof ImageBitmap ? source : yield createImageBitmap(source);\\n                const width = source instanceof HTMLImageElement ? source.naturalWidth : source.width;\\n                const height = source instanceof HTMLImageElement ? source.naturalHeight : source.height;\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[3] = this.context.input;\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNN2XM;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-m.ts?\");\n\n/***/ }),\n\n/***/ \"./src/networks/anime4k/cnn-2x-s.ts\":\n/*!******************************************!*\\\n  !*** ./src/networks/anime4k/cnn-2x-s.ts ***!\n  \\******************************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \\\"./src/layers/anime4k/conv2d-3x4.ts\\\");\\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \\\"./src/layers/anime4k/conv2d-8x4.ts\\\");\\nconst display_1 = __webpack_require__(/*! ../../layers/anime4k/display */ \\\"./src/layers/anime4k/display.ts\\\");\\nclass Anime4KCNN2XS extends base_network_1.default {\\n    constructor(weights) {\\n        super(weights);\\n    }\\n    model() {\\n        const layers = [];\\n        const weights = this.weights.layers;\\n        const context = this.context;\\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\\n        const conv2d_last_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_last_tf'), weights['conv2d_last_tf']);\\n        const paint = new display_1.default([context.buffer('conv2d_last_tf'), context.input], context.texture('output'));\\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_last_tf, paint);\\n        return layers;\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (source instanceof HTMLVideoElement) {\\n                this.context.input = this.context.device.importExternalTexture({ source });\\n            }\\n            else {\\n                const bitmap = source instanceof ImageBitmap ? source : yield createImageBitmap(source);\\n                const width = source instanceof HTMLImageElement ? source.naturalWidth : source.width;\\n                const height = source instanceof HTMLImageElement ? source.naturalHeight : source.height;\\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \\\"rgba8unorm\\\" }) }, [width, height]);\\n                this.context.input = this.context.texture('input');\\n            }\\n            this.layers[0].inputs[0] = this.context.input;\\n            this.layers[this.layers.length - 1].inputs[1] = this.context.input;\\n            this.layers.forEach(function (layer) {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = Anime4KCNN2XS;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-s.ts?\");\n\n/***/ }),\n\n/***/ \"./src/networks/base_network.ts\":\n/*!**************************************!*\\\n  !*** ./src/networks/base_network.ts ***!\n  \\**************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nclass NeuralNetwork {\\n    constructor(weights) {\\n        this.weights = weights;\\n        this.context = globalThis.context;\\n        this.layers = this.model();\\n    }\\n    model() {\\n        return [];\\n    }\\n    lastLayer() {\\n        return this.layers[this.layers.length - 1];\\n    }\\n    feedForward(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            this.layers.forEach(layer => {\\n                layer.run();\\n            });\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = NeuralNetwork;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/base_network.ts?\");\n\n/***/ }),\n\n/***/ \"./src/networks/network_list.ts\":\n/*!**************************************!*\\\n  !*** ./src/networks/network_list.ts ***!\n  \\**************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nexports.NetworkList = void 0;\\nconst cnn_2x_s_1 = __webpack_require__(/*! ./anime4k/cnn-2x-s */ \\\"./src/networks/anime4k/cnn-2x-s.ts\\\");\\nconst cnn_2x_m_1 = __webpack_require__(/*! ./anime4k/cnn-2x-m */ \\\"./src/networks/anime4k/cnn-2x-m.ts\\\");\\nconst cnn_2x_l_1 = __webpack_require__(/*! ./anime4k/cnn-2x-l */ \\\"./src/networks/anime4k/cnn-2x-l.ts\\\");\\nconst poc_network_1 = __webpack_require__(/*! ./poc_network */ \\\"./src/networks/poc_network.ts\\\");\\nexports.NetworkList = {\\n    \\\"anime4k/cnn-2x-s\\\": cnn_2x_s_1.default,\\n    \\\"anime4k/cnn-2x-m\\\": cnn_2x_m_1.default,\\n    \\\"anime4k/cnn-2x-l\\\": cnn_2x_l_1.default,\\n    \\\"sb2702/blur-poc\\\": poc_network_1.default\\n};\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/network_list.ts?\");\n\n/***/ }),\n\n/***/ \"./src/networks/poc_network.ts\":\n/*!*************************************!*\\\n  !*** ./src/networks/poc_network.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, exports, __webpack_require__) => {\n\neval(\"\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst base_network_1 = __webpack_require__(/*! ./base_network */ \\\"./src/networks/base_network.ts\\\");\\nconst rgb_2_yuv_1 = __webpack_require__(/*! ../layers/utils/rgb_2_yuv */ \\\"./src/layers/utils/rgb_2_yuv.ts\\\");\\nconst gaussian_1 = __webpack_require__(/*! ../layers/utils/gaussian */ \\\"./src/layers/utils/gaussian.ts\\\");\\nclass PoCNetwork extends base_network_1.default {\\n    constructor() {\\n        super();\\n    }\\n    model() {\\n        const layers = [];\\n        const context = this.context;\\n        layers.push(new rgb_2_yuv_1.default([context.texture('input')], context.texture('yuv')));\\n        layers.push(new gaussian_1.default([context.texture('yuv')], context.texture('output')));\\n        return layers;\\n    }\\n}\\nexports[\\\"default\\\"] = PoCNetwork;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/networks/poc_network.ts?\");\n\n/***/ }),\n\n/***/ \"./src/renderer.ts\":\n/*!*************************!*\\\n  !*** ./src/renderer.ts ***!\n  \\*************************/\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\neval(\"\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\n    return new (P || (P = Promise))(function (resolve, reject) {\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\n        function rejected(value) { try { step(generator[\\\"throw\\\"](value)); } catch (e) { reject(e); } }\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\n    });\\n};\\nObject.defineProperty(exports, \\\"__esModule\\\", ({ value: true }));\\nconst display_1 = __webpack_require__(/*! ./layers/anime4k/display */ \\\"./src/layers/anime4k/display.ts\\\");\\nconst base_render_layer_1 = __webpack_require__(/*! ./layers/base_render_layer */ \\\"./src/layers/base_render_layer.ts\\\");\\nclass WebSRRenderer {\\n    constructor(network, source) {\\n        this.context = globalThis.context;\\n        this.network = network;\\n        this.source = source;\\n        this.active = false;\\n    }\\n    switchNetwork(network) {\\n        this.network = network;\\n    }\\n    start() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            if (this.context.destroyed) {\\n                throw new Error(\\\"WebSR instance was destroyed\\\");\\n            }\\n            this.active = true;\\n            yield this.renderStep();\\n        });\\n    }\\n    stop() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            this.active = false;\\n            if (this.vfc && this.source && this.source instanceof HTMLVideoElement)\\n                this.source.cancelVideoFrameCallback(this.vfc);\\n        });\\n    }\\n    renderStep() {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const lastLayer = this.network.lastLayer();\\n            if (lastLayer instanceof display_1.default)\\n                lastLayer.setOutput(this.context.context.getCurrentTexture());\\n            yield this.render();\\n            if (this.active && this.source && this.source instanceof HTMLVideoElement) {\\n                this.vfc = this.source.requestVideoFrameCallback(this.renderStep.bind(this));\\n            }\\n        });\\n    }\\n    render(source) {\\n        return __awaiter(this, void 0, void 0, function* () {\\n            const lastLayer = this.network.lastLayer();\\n            if (lastLayer instanceof base_render_layer_1.default)\\n                lastLayer.setOutput(this.context.context.getCurrentTexture());\\n            yield this.network.feedForward(source ? source : this.source);\\n            yield this.context.device.queue.onSubmittedWorkDone();\\n        });\\n    }\\n}\\nexports[\\\"default\\\"] = WebSRRenderer;\\n\\n\\n//# sourceURL=webpack://WebSR/./src/renderer.ts?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_74527__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_74527__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_74527__(\"./src/main.ts\");\n/******/ \t__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack://common/./node_modules/@websr/websr/dist/websr.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawVideoOnCanvas: () => (/* binding */ drawVideoOnCanvas),\n/* harmony export */   getRecvCodec: () => (/* binding */ getRecvCodec),\n/* harmony export */   getWsAddress: () => (/* binding */ getWsAddress),\n/* harmony export */   initComparisons: () => (/* binding */ initComparisons),\n/* harmony export */   initPeerConnection: () => (/* binding */ initPeerConnection),\n/* harmony export */   initSignal: () => (/* binding */ initSignal),\n/* harmony export */   onReceiveICECandidate: () => (/* binding */ onReceiveICECandidate),\n/* harmony export */   onReceiveSDPAnswer: () => (/* binding */ onReceiveSDPAnswer),\n/* harmony export */   onReceiveSDPOffer: () => (/* binding */ onReceiveSDPOffer),\n/* harmony export */   playVideo: () => (/* binding */ playVideo),\n/* harmony export */   printMsg: () => (/* binding */ printMsg),\n/* harmony export */   printPeerCodec: () => (/* binding */ printPeerCodec),\n/* harmony export */   setRecvCodec: () => (/* binding */ setRecvCodec)\n/* harmony export */ });\n/* harmony import */ var _websr_websr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @websr/websr */ \"./node_modules/@websr/websr/dist/websr.js\");\n/* harmony import */ var _websr_websr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_websr_websr__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n// STUN server\n//\nvar stun_address = \"stun:\".concat(window.location.hostname);\n\n// UI\n//\nvar consoleEl = document.getElementById('console');\nvar videoEl = document.getElementById('videoPreview');\nvar codecPreferences = document.getElementById('codec');\nfunction printMsg(msg) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var msgEl = document.createElement('p');\n  if (typeof msg != 'string') {\n    msgEl.innerText = JSON.stringify(msg, null, 2);\n  } else {\n    msgEl.innerText = msg;\n  }\n  if (type != null) msgEl.classList.add(type);\n  consoleEl.appendChild(msgEl);\n  consoleEl.scrollTop = consoleEl.scrollHeight;\n}\nfunction drawVideoOnCanvas() {\n  return _drawVideoOnCanvas.apply(this, arguments);\n}\nfunction _drawVideoOnCanvas() {\n  _drawVideoOnCanvas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var dpr, canvas, srcanvas, gpu, websr, ctx, drawFrame;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          drawFrame = function _drawFrame() {\n            //    \n            ctx.imageSmoothingEnabled = true;\n            ctx.imageSmoothingQuality = \"high\";\n            ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);\n            // ctx.drawImage(canvas, 0, 0, canvas.width * 0.5, canvas.height * 0.5);\n            // ctx.drawImage(canvas, 0, 0, canvas.width * 0.5, canvas.height * 0.5, 0, 0, srcanvas.width, srcanvas.height);\n\n            //     requestAnimationFrame \n            requestAnimationFrame(drawFrame);\n          };\n          //       \n          dpr = window.devicePixelRatio;\n          canvas = document.getElementById('canvas');\n          canvas.width = videoEl.clientWidth * dpr;\n          canvas.height = videoEl.clientHeight * dpr;\n          srcanvas = document.getElementById('sr_video');\n          srcanvas.width = videoEl.clientWidth * dpr;\n          srcanvas.height = videoEl.clientHeight * dpr;\n          _context2.next = 10;\n          return _websr_websr__WEBPACK_IMPORTED_MODULE_0___default().initWebGPU();\n        case 10:\n          gpu = _context2.sent;\n          if (!gpu) printMsg(\"Browser/device doesn't support WebGPU\");\n          _context2.t0 = (_websr_websr__WEBPACK_IMPORTED_MODULE_0___default());\n          _context2.t1 = videoEl;\n          _context2.next = 16;\n          return fetch('./cnn-2x-l.json');\n        case 16:\n          _context2.next = 18;\n          return _context2.sent.json();\n        case 18:\n          _context2.t2 = _context2.sent;\n          _context2.t3 = gpu;\n          _context2.t4 = srcanvas;\n          _context2.t5 = {\n            source: _context2.t1,\n            network_name: \"anime4k/cnn-2x-l\",\n            weights: _context2.t2,\n            gpu: _context2.t3,\n            canvas: _context2.t4\n          };\n          websr = new _context2.t0(_context2.t5);\n          _context2.next = 25;\n          return websr.start();\n        case 25:\n          //   \n          ctx = canvas.getContext('2d'); //      \n          //    \n          drawFrame();\n        case 27:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _drawVideoOnCanvas.apply(this, arguments);\n}\nfunction initComparisons() {\n  var x, i;\n  /* Find all elements with an \"overlay\" class: */\n  x = document.getElementsByClassName(\"img-comp-overlay\");\n  for (i = 0; i < x.length; i++) {\n    /* Once for each \"overlay\" element:\r\n    pass the \"overlay\" element as a parameter when executing the compareImages function: */\n    compareImages(x[i]);\n  }\n  function compareImages(img) {\n    var slider,\n      img,\n      clicked = 0,\n      w,\n      h;\n    /* Get the width and height of the img element */\n    w = img.offsetWidth;\n    h = img.offsetHeight;\n    /* Set the width of the img element to 50%: */\n    img.style.width = w / 2 + \"px\";\n    /* Create slider: */\n    slider = document.createElement(\"DIV\");\n    slider.setAttribute(\"class\", \"img-comp-slider\");\n    /* Insert slider */\n    img.parentElement.insertBefore(slider, img);\n    /* Position the slider in the middle: */\n    slider.style.top = h / 2 - slider.offsetHeight / 2 + \"px\";\n    slider.style.left = w / 2 - slider.offsetWidth / 2 + \"px\";\n    /* Execute a function when the mouse button is pressed: */\n    slider.addEventListener(\"mousedown\", slideReady);\n    /* And another function when the mouse button is released: */\n    window.addEventListener(\"mouseup\", slideFinish);\n    /* Or touched (for touch screens: */\n    slider.addEventListener(\"touchstart\", slideReady);\n    /* And released (for touch screens: */\n    window.addEventListener(\"touchend\", slideFinish);\n    function slideReady(e) {\n      /* Prevent any other actions that may occur when moving over the image: */\n      e.preventDefault();\n      /* The slider is now clicked and ready to move: */\n      clicked = 1;\n      /* Execute a function when the slider is moved: */\n      window.addEventListener(\"mousemove\", slideMove);\n      window.addEventListener(\"touchmove\", slideMove);\n    }\n    function slideFinish() {\n      /* The slider is no longer clicked: */\n      clicked = 0;\n    }\n    function slideMove(e) {\n      var pos;\n      /* If the slider is no longer clicked, exit this function: */\n      if (clicked == 0) return false;\n      /* Get the cursor's x position: */\n      pos = getCursorPos(e);\n      /* Prevent the slider from being positioned outside the image: */\n      if (pos < 0) pos = 0;\n      if (pos > w) pos = w;\n      /* Execute a function that will resize the overlay image according to the cursor: */\n      slide(pos);\n    }\n    function getCursorPos(e) {\n      var a,\n        x = 0;\n      e = e.changedTouches ? e.changedTouches[0] : e;\n      /* Get the x positions of the image: */\n      a = img.getBoundingClientRect();\n      /* Calculate the cursor's x coordinate, relative to the image: */\n      x = e.pageX - a.left;\n      /* Consider any page scrolling: */\n      x = x - window.pageXOffset;\n      return x;\n    }\n    function slide(x) {\n      /* Resize the image: */\n      img.style.width = x + \"px\";\n      /* Position the slider: */\n      slider.style.left = img.offsetWidth - slider.offsetWidth / 2 + \"px\";\n    }\n  }\n}\nfunction playVideo(stream) {\n  if (videoEl.srcObject === stream) return;\n  videoEl.srcObject = stream;\n  videoEl.play();\n  if (window.stream) window.stream.getTracks().forEach(function (track) {\n    return track.stop();\n  });\n  window.stream = stream;\n  printMsg('Stream started', 'success');\n  printMsg(stream.getVideoTracks()[0].getSettings());\n  try {\n    printMsg(stream.getAudioTracks()[0].getSettings());\n  } catch (error) {\n    printMsg('Audio track not found', 'warn');\n  }\n}\nconsoleEl.onclick = function (e) {\n  if (e.target.nodeName == 'P') {\n    window.getSelection().selectAllChildren(e.target);\n    navigator.clipboard.writeText(e.target.innerText);\n  }\n};\n\n// WebSocket\n//\nfunction getWsAddress() {\n  var l = window.location;\n  return (l.protocol == \"https:\" ? \"wss://\" : \"ws://\") + l.host;\n}\nfunction initSignal(name, type) {\n  var socket = new WebSocket(\"\".concat(getWsAddress(), \"/signal?name=\").concat(name, \"&type=\").concat(type));\n  if (window.socket) {\n    if (window.socket.readyState == WebSocket.CONNECTING) {\n      window.socket.onclose = function () {\n        printMsg(\"Closing a CONNECTING websocket\", 'warn');\n      };\n    }\n    window.socket.close(1000, 'new connection requested');\n  }\n  window.socket = socket;\n  socket.onopen = function () {\n    printMsg('Websocket connection established', 'success');\n    printMsg(\"Waiting for \".concat(type == 'host' ? 'client' : 'host', \"...\"));\n  };\n  socket.onmessage = function (e) {\n    try {\n      var msg = JSON.parse(e.data);\n      if (msg.type == 'start') {\n        startPeer();\n      } else if (msg.type == 'offer') {\n        onReceiveSDPOffer(msg.data);\n      } else if (msg.type == 'answer') {\n        onReceiveSDPAnswer(msg.data);\n      } else if (msg.type == 'candidate') {\n        onReceiveICECandidate(msg.data);\n      } else if (msg.type == 'heartbeat') {\n        //logToConsole('Heartbeat received')\n      }\n    } catch (error) {\n      printMsg(\"Error handling message from server:\\n\".concat(error));\n    }\n  };\n  socket.onclose = function (e) {\n    printMsg(\"Websocket connection closed (\".concat(e.code, \"), reason: \").concat(e.reason), 'error');\n    if (!e.wasClean) {\n      printMsg('Attempting to reconnect...', 'error');\n      setTimeout(function () {\n        initSignal(name, type);\n      }, 1000);\n    }\n  };\n}\n\n// WebSocket heartbeat\nsetInterval(function () {\n  try {\n    if (window.socket.readyState == WebSocket.OPEN) {\n      window.socket.send(JSON.stringify({\n        type: 'heartbeat'\n      }));\n    }\n  } catch (error) {}\n}, 5000);\n\n// RTC event handlers\n//\nfunction initPeerConnection() {\n  printMsg(\"Initiating peer connection\");\n  try {\n    var peerConnection = new RTCPeerConnection({\n      iceServers: [{\n        urls: stun_address\n      }]\n    });\n  } catch (error) {\n    printMsg(\"Your browser doesn't support WebRTC (RTCPeerConnection)\", 'error');\n    return;\n  }\n  if (window.peerConnection) window.peerConnection.close();\n  window.peerConnection = peerConnection;\n  peerConnection.onnegotiationneeded = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var offer;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return peerConnection.createOffer();\n        case 2:\n          offer = _context.sent;\n          printMsg('Created SDP offer:', 'warn');\n          printMsg(offer, 'warn');\n          peerConnection.setLocalDescription(offer);\n          socket.send(JSON.stringify({\n            type: 'offer',\n            data: offer\n          }));\n          printMsg('SDP offer sent');\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  peerConnection.onicecandidate = function (e) {\n    if (e.candidate) {\n      printMsg('Created ICE candidate:', 'warn');\n      printMsg(e.candidate, 'warn');\n      socket.send(JSON.stringify({\n        type: 'candidate',\n        data: e.candidate\n      }));\n      printMsg('ICE candidate sent');\n    }\n  };\n  peerConnection.oniceconnectionstatechange = function (e) {\n    var state = e.currentTarget.iceConnectionState;\n    printMsg(\"Connection state changed: \".concat(state), state == 'connected' ? 'success' : 'warn');\n  };\n  peerConnection.onicegatheringstatechange = function (e) {\n    printMsg(\"ICE gathering state: \".concat(e.target.iceGatheringState));\n  };\n}\nfunction onReceiveSDPOffer(_x) {\n  return _onReceiveSDPOffer.apply(this, arguments);\n}\nfunction _onReceiveSDPOffer() {\n  _onReceiveSDPOffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(sdp) {\n    var answer;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          printMsg('Received SDP offer:', 'success');\n          printMsg(sdp, 'success');\n          _context3.next = 4;\n          return peerConnection.setRemoteDescription(sdp);\n        case 4:\n          // change preferred codec before creating SDP answer\n          setRecvCodec();\n          _context3.next = 7;\n          return peerConnection.createAnswer();\n        case 7:\n          answer = _context3.sent;\n          printMsg('Created SDP answer:', 'warn');\n          printMsg(answer, 'warn');\n          _context3.next = 12;\n          return peerConnection.setLocalDescription(answer);\n        case 12:\n          socket.send(JSON.stringify({\n            type: 'answer',\n            data: answer\n          }));\n          printMsg('SDP answer sent');\n        case 14:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _onReceiveSDPOffer.apply(this, arguments);\n}\nfunction onReceiveSDPAnswer(_x2) {\n  return _onReceiveSDPAnswer.apply(this, arguments);\n}\nfunction _onReceiveSDPAnswer() {\n  _onReceiveSDPAnswer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(sdp) {\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          printMsg('Received SDP answer:', 'success');\n          printMsg(sdp, 'success');\n\n          // modify SDP to achieve higher bitrate (Chrome only)\n          printMsg('Modified SDP:');\n          sdp.sdp = sdp.sdp.replace(/(m=video.*\\r\\n)/g, \"$1b=AS:\".concat(parseInt(document.getElementById('bitrate').value), \"\\r\\n\"));\n          printMsg(sdp);\n          _context4.next = 7;\n          return peerConnection.setRemoteDescription(sdp);\n        case 7:\n          // actual codec after negotiation\n          printPeerCodec();\n        case 8:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _onReceiveSDPAnswer.apply(this, arguments);\n}\nfunction onReceiveICECandidate(candidate) {\n  printMsg('Received remote ICE candidate:', 'success');\n  printMsg(candidate, 'success');\n  peerConnection.addIceCandidate(candidate);\n}\n\n// Misc\n//\nfunction printPeerCodec() {\n  peerConnection.getStats().then(function (stats) {\n    stats.forEach(function (stat) {\n      if (stat.type == 'codec') {\n        printMsg(\"Using codec: \".concat(stat.mimeType, \" \").concat(stat.sdpFmtpLine || ''));\n      }\n    });\n  });\n}\nfunction getRecvCodec() {\n  var _RTCRtpReceiver$getCa = RTCRtpReceiver.getCapabilities('video'),\n    codecs = _RTCRtpReceiver$getCa.codecs;\n  codecs.forEach(function (codec) {\n    if (['video/red', 'video/ulpfec', 'video/rtx'].includes(codec.mimeType)) {\n      return;\n    }\n    var codecStr = (codec.mimeType + ' ' + (codec.sdpFmtpLine || '')).trim();\n    var option = document.createElement('option');\n    option.value = codecStr;\n    option.innerText = option.value;\n    codecPreferences.appendChild(option);\n  });\n  codecPreferences.disabled = false;\n}\nfunction setRecvCodec() {\n  try {\n    var preferredCodec = codecPreferences.value;\n    if (preferredCodec !== '') {\n      var _preferredCodec$split = preferredCodec.split(' '),\n        _preferredCodec$split2 = _slicedToArray(_preferredCodec$split, 2),\n        mimeType = _preferredCodec$split2[0],\n        sdpFmtpLine = _preferredCodec$split2[1];\n      var _RTCRtpReceiver$getCa2 = RTCRtpReceiver.getCapabilities('video'),\n        codecs = _RTCRtpReceiver$getCa2.codecs;\n      var selectedCodecIndex = codecs.findIndex(function (c) {\n        return c.mimeType === mimeType && c.sdpFmtpLine === sdpFmtpLine;\n      });\n      var selectedCodec = codecs[selectedCodecIndex];\n      codecs.splice(selectedCodecIndex, 1);\n      codecs.unshift(selectedCodec);\n      peerConnection.getTransceivers().forEach(function (transceiver) {\n        if (transceiver.receiver.track.kind == 'video') transceiver.setCodecPreferences(codecs);\n      });\n    }\n  } catch (error) {\n    printMsg(\"Failed to set preferred codec: \".concat(error), 'warn');\n  }\n}\n\n//# sourceURL=webpack://common/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	common = __webpack_exports__;
/******/ 	
/******/ })()
;